<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.27">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Abbreviated Fundamentals of the Command Line Interface">

<title>Shell and Terminal on Mac – Dan Yavorsky</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<link href="../..//images/favicon.ico" rel="icon">
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-ed96de9b727972fe78a7b5d16c58bf87.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-2a96bab85b891114d78a8961617f29ca.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../custom.scss">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Dan Yavorsky</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> <i class="bi bi-person-circle" role="img">
</i> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../cv/index.html"> <i class="bi bi-file-earmark-check" role="img">
</i> 
<span class="menu-text">Resume</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../teaching/index.html"> <i class="bi bi-mortarboard" role="img">
</i> 
<span class="menu-text">Teaching</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../pubs/index.html"> <i class="bi bi-journals" role="img">
</i> 
<span class="menu-text">Pubs</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../posts/index.html"> <i class="bi bi-pencil-square" role="img">
</i> 
<span class="menu-text">Posts</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-links" role="link" data-bs-toggle="dropdown" aria-expanded="false">
      <i class="bi bi-link-45deg" role="img">
</i> 
 <span class="menu-text">Links</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-links">    
        <li>
    <a class="dropdown-item" href="../../links/r.html"><i class="bi bi-r-circle" role="img">
</i> 
 <span class="dropdown-text">R Programming</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../links/compute.html"><i class="bi bi-terminal" role="img">
</i> 
 <span class="dropdown-text">Computing</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../links/stats.html"><i class="bi bi-bar-chart" role="img">
</i> 
 <span class="dropdown-text">Stats</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../links/advice.html"><i class="bi bi-info-square" role="img">
</i> 
 <span class="dropdown-text">Advice</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../links/blogs.html"><i class="bi bi-file-text" role="img">
</i> 
 <span class="dropdown-text">Blogs</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../links/quotes.html"><i class="bi bi-chat-quote" role="img">
</i> 
 <span class="dropdown-text">Quotes</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
    <a href="https://github.com/dyavorsky/quarto_website" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-github"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Shell and Terminal on Mac</h1>
                  <div>
        <div class="description">
          Abbreviated Fundamentals of the Command Line Interface
        </div>
      </div>
                </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#whats-what" id="toc-whats-what" class="nav-link active" data-scroll-target="#whats-what">What’s what</a></li>
  <li><a href="#shell-basics" id="toc-shell-basics" class="nav-link" data-scroll-target="#shell-basics">Shell Basics</a>
  <ul class="collapse">
  <li><a href="#moving-around" id="toc-moving-around" class="nav-link" data-scroll-target="#moving-around">Moving around</a></li>
  <li><a href="#editing-text-at-the-command-line" id="toc-editing-text-at-the-command-line" class="nav-link" data-scroll-target="#editing-text-at-the-command-line">Editing Text at the Command Line</a></li>
  <li><a href="#combining-tools" id="toc-combining-tools" class="nav-link" data-scroll-target="#combining-tools">Combining tools</a></li>
  <li><a href="#regular-expressions" id="toc-regular-expressions" class="nav-link" data-scroll-target="#regular-expressions">Regular Expressions</a></li>
  <li><a href="#sections-to-add" id="toc-sections-to-add" class="nav-link" data-scroll-target="#sections-to-add">Sections to add</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="whats-what" class="level2">
<h2 class="anchored" data-anchor-id="whats-what">What’s what</h2>
<p>Most users of personal computers today are intimately familiar with the <strong>graphical user interface</strong> (GUI) where interactions with the computer typically involve using a mouse (and sometimes the keyboard) to click and navigate through windows, icons, menus, and buttons.</p>
<p>Before GUIs became common, computers were often operated through a text-based method called a <strong>command-line interface</strong> (CLI). And this approach is sill widely used today.</p>
<p>In the “old days,” most computers would boot into the CLI because there was no graphical altnernative. Today, every major operating system still includes a way to access the command line through an application called a terminal emulator (or just <strong>terminal</strong> for short). On macOS, the app is unceremoniously named “Terminal” and can be found in the <code>/Applications/Utilities</code> directory. But you can download other terminal applications, including <a href="https://iterm2.com/">iTerm2</a>, <a href="https://www.warp.dev/">Warp</a>, <a href="https://alacritty.org/">Alacritty</a>, <a href="https://hyper.is/">Hyper</a>, <a href="https://tabby.sh/">Tabby</a>, <a href="https://sw.kovidgoyal.net/kitty/">Kitty</a>, <a href="https://raphamorim.io/rio/">Rio</a>, or others.</p>
<p>Every terminal application has a text-based input field called the <strong>command line</strong> that begins with a <strong>prompt</strong> (usually <code>&gt;</code> or <code>$</code>). When you type and submit a command, the Shell Command Line Interpreter (or just <strong>Shell</strong>) parses and interprets the text you have typed, carrying out your instructions and possibly returning information to you in the terminal. This Read-Eval-Print loop (<strong>REPL</strong>) is common when computer programs allow “live” interaction between the user and computer.</p>
<p>The default shell on macOS at the time of writing is <strong>zsh</strong> (pronounced the “Z shell”) which replaced <strong>bash</strong> (the “Bourne Again SHell”) as the macOS default starting with the release of macOS Catalina in 2019. bash, as evidenced by its name, was an evolution of the Bourne shell (with the short name <strong>sh</strong>). To round out the list, the <a href="https://www.reddit.com/r/linux4noobs/comments/12wfzb8/best_shell_in_your_opinion_2023/">only</a> other popular shell today is <strong>fish</strong> (the “friendly” shell).</p>
</section>
<section id="shell-basics" class="level2">
<h2 class="anchored" data-anchor-id="shell-basics">Shell Basics</h2>
<p>First, let’s determine what shell you are using. Open your terminal application and type <code>echo $SHELL</code> at the command prompt. If the response is <code>/bin/zsh</code> then its zsh.</p>
<p>Most commands tend to have the following structure</p>
<pre><code>[command] [options] [arguments]</code></pre>
<p>You’ll need help. Often. The commands <code>run-help</code> and <code>man</code> (short for manual) following by a command name will bring up the command’s documentation using the terminal pager <strong>less</strong>. For navigation, arrow keys move one line at a time, page up/down and the spacebar move one page at a time, and <code>q</code> exits. For more succinct documentation, visit <a href="https://tldr.sh/">https://tldr.sh/</a> in a browser, which can be used interactively or downloaded.</p>
<section id="moving-around" class="level3">
<h3 class="anchored" data-anchor-id="moving-around">Moving around</h3>
<p>Navigating the hierarchy of directories and performing simple operations on files are fundamental to working from the command line. Note that many of the following tools take the verbose <code>-v</code> option, which prints a confirmation message in the terminal and is useful to “see” what these commands do, especially while learning them.</p>
<ul>
<li><code>pwd</code> prints the current (working) directory</li>
<li><code>cd</code> changes the working directory</li>
<li><code>ls</code> list the contents of a directory</li>
<li><code>..</code> denote the parent directory</li>
<li><code>.</code> denotes the current directory (useful, eg, when copying)</li>
</ul>
<p>Creating, moving, copying, and deleting files and directories are common operations:</p>
<ul>
<li><code>touch</code> updates the access and modification times of files, but also creates a file if it does not yet exist</li>
<li><code>mv</code> move (or rename) one or more files or directories</li>
<li><code>cp</code> copy one or more files or directories</li>
<li><code>rm</code> remove (ie, permanently delete) file(s). A good alternative is to “trash” them with <code>mv file_name ~/.Trash</code></li>
<li><code>mkdir</code> create a new directory</li>
<li><code>rmdir</code> removes directories (use with caution!) A good alternative is to “trash” them by installing the trash command with <code>brew install trash</code> and then running <code>trash dir_name</code></li>
</ul>
<p>It is often useful to use wildcards to return a “group” of files. Common wildcards include:</p>
<ul>
<li><code>*</code> denotes zero or more characters</li>
<li><code>?</code> a single character</li>
<li><code>[abc]</code> a list of permited characters</li>
<li><code>[a-z]</code> a set of characters</li>
</ul>
</section>
<section id="editing-text-at-the-command-line" class="level3">
<h3 class="anchored" data-anchor-id="editing-text-at-the-command-line">Editing Text at the Command Line</h3>
<p>When working in a terminal, you’ll often need to edit what you’ve typed, e.g., to fix a typo, move back a few words, delete a chunk of text, or recall and modify a previous command. While you can do this with arrow keys and backspace, you’ll become dramatically faster once you learn a handful of editing shortcuts.</p>
<p>Most shells (including zsh and bash) provide “line editing,” meaning you can edit the current command before you run it. These editing features come from a library called readline (used by bash) or a similar system called zle (the Zsh Line Editor). Both support two classic styles of keybindings: Emacs-style editing (the default in most shells) and Vi-style editing (popular among Vim users). These styles trace back to two influential text editors from the 1970s: Emacs and vi, which shaped how programmers interact with text even to this day.</p>
<section id="emacs-style-keybindings-default" class="level4">
<h4 class="anchored" data-anchor-id="emacs-style-keybindings-default">Emacs-style keybindings (default)</h4>
<p>In Emacs mode, you use Control key combinations to move and edit efficiently. These are widely supported across shells and many terminal programs. Here are the most useful ones to memorize. Note that on the macOS Terminal, “Alt” is often the Option key.</p>
<ul>
<li><code>Ctrl-A</code> jump to the beginning of the line</li>
<li><code>Ctrl-E</code> jump to the end of the line</li>
<li><code>Ctrl-B</code> move back one letter</li>
<li><code>Ctrl-F</code> move forward one letter</li>
<li><code>Alt-B</code> or <code>Esc-B</code> move back one word</li>
<li><code>Alt-F</code> or <code>Esc-F</code> move forward one word</li>
<li><code>Ctrl-L</code> clear the screen</li>
<li><code>Ctrl-U</code> delete from cursor to the beginning of the line (“undo this whole front part”)</li>
<li><code>Ctrl-K</code> delete from cursor to the end of the line (“kill to end”)</li>
<li><code>Ctrl-W</code> delete the word behind the cursor</li>
<li><code>Ctrl-P</code> previous command (same as up arrow)</li>
<li><code>Ctrl-N</code> next command (same as down arrow)</li>
<li><code>Ctrl-R</code> reverse search through history (Start typing part of a previous command and press Ctrl-R repeatedly to cycle matches.)</li>
</ul>
</section>
<section id="vi-style-keybindings-modal-editing" class="level4">
<h4 class="anchored" data-anchor-id="vi-style-keybindings-modal-editing">Vi-style keybindings (modal editing)</h4>
<p>Vi mode is “modal,” meaning you switch between modes: “Insert” mode where you type normally, or “Normal” mode where keys perform editing commands. This feels strange at first, but you can become extremely fast once it clicks. Vi’s reputation is that you can move mountains in a few keystrokes, but with the cost that even simple operations also require a few keystrokes.</p>
<p>To change from the default emacs-style key binding to vi-style for the current shell session, run <code>bindkey -v</code> or <code>set -o vi</code>. To enable vi-style keybinding every time you start an interactive shell, add one of those commands to your shell configuration file (typically ~/.zshrc for zsh or ~/.bashrc for bash). Then either restart your terminal or reload the configuration with source <code>~/.zshrc</code>.</p>
<p>Once enabled, when you’re typing a command you’re usually in insert mode. Press:</p>
<ul>
<li><code>Esc</code> switch to normal mode</li>
<li><code>i</code> return to insert mode at the cursor</li>
<li><code>a</code> return to insert mode after the cursor</li>
</ul>
<p>In normal mode, a typical operation folows the pattern count-operator-motion/object. For example, <code>3dw</code> deletes forward three words. Omitting the count is typica, for example <code>ci(</code> changes the text inside the current set of parentheses. Common commands include:</p>
<p>Movement of cursor</p>
<ul>
<li><code>h/l</code> left/right</li>
<li><code>0</code> beginning of line</li>
<li><code>$</code> end of line</li>
<li><code>w</code> forward one word</li>
<li><code>b</code> back one word</li>
</ul>
<p>Editing (normal mode)</p>
<ul>
<li><code>x</code> delete character under cursor</li>
<li><code>dw</code> delete a word</li>
<li><code>dd</code> delete the entire line</li>
<li><code>cw</code> change a word (delete word and enter insert mode)</li>
<li><code>D</code> delete from cursor to end of line</li>
</ul>
<p>History search</p>
<ul>
<li><code>j/k</code> up/down</li>
<li><code>/text</code> search backward in history for “text”</li>
<li><code>n</code> repeat the last search</li>
</ul>
<p>A common workflow looks like: type a command; hit Esc; quickly edit with w, b, dw, etc.; press i to insert again; run.</p>
</section>
</section>
<section id="combining-tools" class="level3">
<h3 class="anchored" data-anchor-id="combining-tools">Combining tools</h3>
<p>The Unix philosophy is that command line tools are designed to do one thing and to do it well. Therefore, complex operations are created through a composition of tools. This is made possible by managing the communication streams of these tools. Each has 3 standard communication streams: standard input (<code>stdin</code>), standard output (<code>stdout</code>), and standard error (<code>stderr</code>). Often, the keyboard will not be the source of input, but rather it will be from the output generated by other tools and contents of files.</p>
<ul>
<li><code>&lt;</code> takes input from a file (eg, <code>&lt; file.txt wc</code>)</li>
<li><code>&gt;</code> directs output to a file and overwrites (eg, <code>ls &gt; dir_contents.txt</code>)</li>
<li><code>&gt;&gt;</code> directs output to a file and appends</li>
<li><code>|</code> pipes output from one command to input of another (eg, <code>ls | less</code>)</li>
</ul>
<p>Common tools for inspecting files, or for gathering and summarizing their contents include:</p>
<ul>
<li><code>cat</code> for concatenating files; can be used to print file contents in the terminal for short files</li>
<li><code>find</code> for recursively searching a directory hierarchy returning names of files and/or directories</li>
<li><code>wc</code> for counting characters, words, and lines</li>
<li><code>head</code> for obtaining the first few lines</li>
<li><code>tail</code> for obtaining the last few lines</li>
<li><code>sort</code> for sorting the contents of a file</li>
<li><code>uniq</code> for removing adjacent duplicates</li>
</ul>
<p>More-advanced tools that deserve their own section and explanation</p>
<ul>
<li><code>grep</code> for matching a Regular Expression pattern in one or more files</li>
<li><code>sed</code> a stream editor for modifying data</li>
<li><code>awk</code> a data processing language named after its creators</li>
</ul>
</section>
<section id="regular-expressions" class="level3">
<h3 class="anchored" data-anchor-id="regular-expressions">Regular Expressions</h3>
</section>
<section id="sections-to-add" class="level3">
<h3 class="anchored" data-anchor-id="sections-to-add">Sections to add</h3>
<ul>
<li>File permissions (read/write/execute)</li>
<li>A whole section on each of grep/sed/awk</li>
<li>Connecting: ssh/ftp/curl</li>
<li>Environment variables (incl.&nbsp;customizing the prompt)</li>
<li>Writing programs (incl.&nbsp;if/for/while)</li>
</ul>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/www\.danyavorsky\.com");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>